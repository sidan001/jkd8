### 调整线程池的大小
《Java并发编程实战》（http://mng.bz/979c）一书中，Brian Goetz和合著者们为线程池大小
的优化提供了不少中肯的建议。这非常重要，如果线程池中线程的数量过多，最终它们会竞争
稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正
如你的应用所面临的情况，处理器的一些核可能就无法充分利用。Brian Goetz建议，线程池大
小与处理器的利用率之比可以使用下面的公式进行估算：
N<sub>threads</sub> = N<sub>CPU</sub> * U<sub>CPU</sub> * (1 + W/C)
其中：
* N<sub>CPU</sub>是处理器的核的数目，可以通过Runtime.getRuntime().availableProcessors()
得到
* U<sub>CPU</sub>是期望的CPU利用率（该值应该介于0和1之间）
* W/C是等待时间与计算时间的比率


### 并行——使用流还是CompletableFutures？
目前为止，你已经知道对集合进行并行计算有两种方式：要么将其转化为并行流，利用map
这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在`Completable-
Future`内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助
你确保整体的计算不会因为线程都在等待I/O而发生阻塞。
我们对使用这些API的建议如下。
* 如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用`Stream`接口，因为实
现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要
创建比处理器核数更多的线程）。
* 反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用
`CompletableFuture`灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者
W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的
流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。
